<!DOCTYPE html>
<html>
  <body>
    <div id="canvas-wrap"></div>

    <script src="node_modules/howler/dist/howler.js"></script>
    <script>
      const se_hit = new Howl({
        src: ['audio/hit01.mp3']
      });

      const cfg = {
        "canvas": {
          "width": 400,
          "height": 400
        },
        "ball": {
          "width": 6,
          "height": 6,
          "speed": 4,
          "damage": 1
        },
        "paddle": {
          "width": 100,
          "height": 15,
          "speed": 4
        },
        "grid": {
          "width": 6,
          "height": 6,
          "canvas_ratio_x": 1,
          "canvas_ratio_y": 0.4,
          "level": [
              [0,0,0,0,0,0],
              [0,1,1,1,1,0],
              [0,1,1,1,1,0],
              [0,1,1,1,1,0],
              [0,1,1,1,1,0],
              [0,1,1,1,1,0]
          ]
        }
      };

      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext('2d');
      
      canvas.width = cfg.canvas.width;
      canvas.height = cfg.canvas.height;
      canvas.setAttribute('style', 'display:inline-block;margin:auto;background-color: #ddd');

      const canvas_ui = document.createElement("canvas");
      const ctx_ui = canvas_ui.getContext('2d');
      
      canvas_ui.width = 200;
      canvas_ui.height = cfg.canvas.height;
      canvas_ui.setAttribute('style', 'display:inline-block;margin:auto;background-color: #aaa');

      const canvas_wrap = document.getElementById('canvas-wrap')
      canvas_wrap.appendChild(canvas);
      canvas_wrap.appendChild(canvas_ui);

      ctx_ui.font = '20pt sans-serif';
      ctx_ui.textAlign = 'center'
      ctx_ui.fillText('LEVEL', canvas_ui.width / 2, 30)
      ctx_ui.fillText('SCORE', canvas_ui.width / 2, 120)
      ctx_ui.fillText('LIFE', canvas_ui.width / 2, 210)

      const manager = {
        state: null
      };
      
      const img = new Image();
      img.src = "img/ball.png";
      img.onload = () => {
        img.width = ball.width;
        img.height = ball.height;
      };

      const ball = {
        x: null,
        y: null,
        width: cfg.ball.width,
        height: cfg.ball.height,
        speed: cfg.ball.speed,
        dx: null,
        dy: null,
        damage: cfg.ball.damage,
        hit_x: function() {
          this.dx > 0 ? this.x -= this.width : this.x += this.width;
          this.dx *= -1;
          se_hit.play();
        },
        hit_y: function() {
          this.dy > 0 ? this.y -= this.height : this.y += this.height;
          this.dy *= -1;
          se_hit.play();
        },
        update: function() {
          this.x += this.dx;
          this.y += this.dy;
        },
        draw: function() {
          //ctx.fillRect(this.x, this.y, this.width, this.height);
          //ctx.stroke();

          ctx.drawImage(img, this.x, this.y, this.width, this.height);
        }
          
      }
      const paddle = {
        x: null,
        y: null,
        width: cfg.paddle.width,
        height: cfg.paddle.height,
        speed: cfg.paddle.speed,
        dx: null,
        
        update: function() {
          if(this.x + this.dx > 0 && this.x + this.width + this.dx < canvas.width) this.x += this.dx;
        },
        draw: function() {
          ctx.fillRect(this.x, this.y, this.width, this.height);
          ctx.fill();
        }
      }
      const block = {
        idx: null,
        width: null,
        height: null,
        data: {},
        draw: function() {
          for(key in this.data) {
            brick = this.data[key]
            ctx.strokeRect(brick.x, brick.y, brick.width, brick.height);
            ctx.stroke();
          }
        }
      }
      const grid = cfg.grid
      
      const init = () => {
        console.log('init');
        manager.state = 'ready'
        paddle.x = canvas.width / 2 - paddle.width / 2;
        paddle.y = canvas.height - paddle.height;
        
        ball.x = canvas.width / 2;
        ball.y = canvas.height / 2 + 50;
        ball.dx = ball.speed;
        ball.dy = ball.speed;
        
        block.width = (grid.canvas_ratio_x * canvas.width) / grid.width
        block.height = (grid.canvas_ratio_y * canvas.height) / grid.height
        
        let k = 0;
        for(let i=0; i<grid.height; i++) {
          for(let j=0; j<grid.width; j++) {
            if(grid.level[i][j]) {
              block.data[k] = {
                x: block.width * j,
                y: block.height * i,
                width: block.width,
                height: block.height,
                HP: grid.level[i][j]
              };
            }
            k++;
          }
        }
      }
      
      const collide = (obj1, obj2) => {
        /*
        return obj1.x < obj2.x + obj2.width && 
          obj2.x < obj1.x + obj1.width && 
          obj1.y < obj2.y + obj2.height && 
          obj2.y < obj1.y + obj1.height;
        */
        x_left = Math.max(obj1.x, obj2.x);
        x_right = Math.min(obj1.x + obj1.width, obj2.x + obj2.width);
        y_top = Math.max(obj1.y, obj2.y);
        y_bottom = Math.min(obj1.y + obj1.height, obj2.y + obj2.height);
        w = Math.max(x_right - x_left, 0);
        h = Math.max(y_bottom - y_top, 0);
        if(w * h > 0) {
          return w > h ? [false, true] : [true, false]
        } else {
          return [false, false];
        }
      }
      
      const clamp = (x, min, max) => {
        return Math.min(Math.max(x, min), max);
      }

      const loop = () => {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        paddle.draw();
        ball.draw();
        block.draw();
        if (manager.state == 'play') {
          paddle.update();
          ball.update();

          if(ball.x < 0 || ball.x > canvas.width) ball.hit_x();
          if(ball.y < 0 || ball.y > canvas.height) ball.hit_y();
          
          [collision_x, collision_y] = collide(ball, paddle);
          collision_x ? ball.hit_x() : collision_y ? ball.hit_y() : ""

          if (ball.y < canvas.height * grid.canvas_ratio_y) {
            ball_center_x = ball.x + ball.width / 2;
            ball_center_y = ball.y + ball.height / 2;
            x_index = Math.floor(ball_center_x / block.width);
            y_index = Math.floor(ball_center_y / block.height);
            index_keys = [
              x_index + y_index * grid.width,
              (x_index - 1) + y_index * grid.width,
              x_index + (y_index - 1) * grid.width,
              (x_index + 1) + y_index * grid.width,
              x_index + (y_index + 1) * grid.width
            ];

            for (const idx of index_keys) {
              if (idx in block.data) {
                [collision_x, collision_y] = collide(ball, block.data[idx]);
                collision_x ? ball.hit_x() : collision_y ? ball.hit_y() : ""
                if (collision_x || collision_y) {
                  brick.HP -= ball.damage;
                  if (brick.HP < 1) delete block.data[idx];
                }
              }
            }
          }
        }
        
        window.requestAnimationFrame(loop);
      }
      
      init();
      loop();

      document.addEventListener('keydown', e => {
        if(e.key == 'ArrowLeft') paddle.dx = -1 * paddle.speed;
        if(e.key == 'ArrowRight') paddle.dx = paddle.speed;
        if(e.key == 's' && manager.state == 'ready') manager.state = 'play';
        if(e.key == 'r' && manager.state == 'play') {
          manager.state = 'ready';
          init();
        }
      });
      document.addEventListener('keyup', () => {
        paddle.dx = 0;
      });
      
    </script>
  </body>
</html>
