<!DOCTYPE html>
<html>
  <body>
    <div id="canvas-wrap"></div>

    <script src="node_modules/howler/dist/howler.js"></script>
    <script>
      const se_hit = new Howl({
        src: ['audio/hit01.mp3']
      });

      const cfg = {
        "canvas": {
          "width": 400,
          "height": 600
        },
        "ball": {
          "width": 6,
          "height": 6,
          "speed": 4,
          "damage": 1,
          "ricochet_ratio": 0.5,
        },
        "paddle": {
          "width": 100,
          "height": 15,
          "speed": 4,
          "center_ratio": 0.2,
          "edge_ratio": 0.2
        },
        "grid": {
          "width": 12,
          "height": 8,
          "canvas_ratio_x": 0.8,
          "canvas_ratio_y": 0.4,
          "alignment": [
              [0,0,0,0,0,0,0,0,0,0,0,0],
              [0,1,1,1,1,0,0,1,1,1,1,0],
              [0,1,1,1,1,0,0,1,1,1,1,0],
              [0,1,1,1,1,0,0,1,1,1,1,0],
              [0,1,1,1,1,0,0,1,1,1,1,0],
              [0,1,1,1,1,0,0,1,1,1,1,0],
              [0,1,1,1,1,0,0,1,1,1,1,0],
              [0,0,0,0,0,0,0,0,0,0,0,0]
          ]
        },
        "life": 3
      };

      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext('2d');
      
      canvas.width = cfg.canvas.width;
      canvas.height = cfg.canvas.height;
      canvas.setAttribute('style', 'display:inline-block;margin:auto;background-color: #ddd');

      const canvas_ui = document.createElement("canvas");
      const ctx_ui = canvas_ui.getContext('2d');
      
      canvas_ui.width = 200;
      canvas_ui.height = cfg.canvas.height;
      canvas_ui.setAttribute('style', 'display:inline-block;margin:auto;background-color: #aaa');

      const canvas_wrap = document.getElementById('canvas-wrap')
      canvas_wrap.appendChild(canvas);
      canvas_wrap.appendChild(canvas_ui);

      ctx_ui.font = '20pt sans-serif';
      ctx_ui.textAlign = 'center'
      ctx_ui.fillText('LEVEL', canvas_ui.width / 2, 30)
      ctx_ui.fillText('SCORE', canvas_ui.width / 2, 120)
      ctx_ui.fillText('LIFE', canvas_ui.width / 2, 210)

      const manager = {
        state: null,
        score: null,
        life:  null,
        level: null,
        init: function () {
          this.state = 'ready';
          this.score = 0;
          this.level = 1;
          this.life = cfg.life 
        }
      };
      
      const img = new Image();
      img.src = "img/ball.png";
      img.onload = () => {
        img.width = ball.width;
        img.height = ball.height;
      };

      const ball = {
        x: null,
        y: null,
        width: cfg.ball.width,
        height: cfg.ball.height,
        speed: cfg.ball.speed,
        dx: null,
        dy: null,
        damage: cfg.ball.damage,
        is_bullet: false,
        ricochet_ratio: cfg.ball.ricochet_ratio,
        hit_x: function() {
          this.dx > 0 ? this.x -= this.width : this.x += this.width;
          this.dx *= -1;
          se_hit.play();
        },
        hit_y: function() {
          this.dy > 0 ? this.y -= this.height : this.y += this.height;
          this.dy *= -1;
          se_hit.play();
        },
        update: function() {
          scale = this.is_bullet ? 1.5 : 1.0
          this.x += scale * this.dx;
          this.y += scale * this.dy;
        },
        draw: function() {
          //ctx.fillRect(this.x, this.y, this.width, this.height);
          //ctx.stroke();

          ctx.drawImage(img, this.x, this.y, this.width, this.height);
        },
        init: function() {
          this.x = paddle.x + paddle.width / 2 - ball.width / 2;
          this.y = paddle.y - ball.height;
          this.dx = ball.speed;
          this.dy = -1 * ball.speed;
        }
      }
      const paddle = {
        x: null,
        y: null,
        width: cfg.paddle.width,
        height: cfg.paddle.height,
        speed: cfg.paddle.speed,
        dx: null,
        center_ratio: cfg.paddle.center_ratio,
        edge_ratio: cfg.paddle.edge_ratio,
        
        update: function() {
          if(this.x + this.dx > 0 && this.x + this.width + this.dx < canvas.width) this.x += this.dx;
        },
        draw: function() {
          ctx.fillRect(this.x, this.y, this.width, this.height);
          ctx.fill();
        },
        is_hit_center: function(ball_center_x) {
          paddle_center_x = this.x + this.width / 2
          radius = 0.5 * this.width * this.center_ratio;
          return Math.abs(ball_center_x - paddle_center_x) < radius
        },
        is_hit_chip: function(ball_center_x) {
          paddle_center_x = this.x + this.width / 2;
          radius = 0.5 * this.width * (1 - this.edge_ratio);
          return Math.abs(ball_center_x - paddle_center_x) > radius
        }
      }
      const block = {
        idx: null,
        width: null,
        height: null,
        data: {},
        draw: function() {
          for(key in this.data) {
            brick = this.data[key]
            ctx.strokeRect(brick.x, brick.y, brick.width, brick.height);
            ctx.stroke();
          }
        }
      }
      const grid = cfg.grid
      
      const init = () => {
        console.log('init');
        paddle.x = canvas.width / 2 - paddle.width / 2;
        paddle.y = canvas.height - paddle.height;
        
        ball.init();
        
        block.width = (grid.canvas_ratio_x * canvas.width) / grid.width
        block.height = (grid.canvas_ratio_y * canvas.height) / grid.height
        margin_x = 0.5 * (1 - grid.canvas_ratio_x) * canvas.width;
        
        let k = 0;
        for(let i=0; i<grid.height; i++) {
          for(let j=0; j<grid.width; j++) {
            if(grid.alignment[i][j]) {
              block.data[k] = {
                x: margin_x + block.width * j,
                y: block.height * i,
                width: block.width,
                height: block.height,
                HP: grid.alignment[i][j]
              };
            }
            k++;
          }
        }
        manager.init();
      }
      
      const collide = (obj1, obj2) => {
        /*
        return obj1.x < obj2.x + obj2.width && 
          obj2.x < obj1.x + obj1.width && 
          obj1.y < obj2.y + obj2.height && 
          obj2.y < obj1.y + obj1.height;
        */
        x_left = Math.max(obj1.x, obj2.x);
        x_right = Math.min(obj1.x + obj1.width, obj2.x + obj2.width);
        y_top = Math.max(obj1.y, obj2.y);
        y_bottom = Math.min(obj1.y + obj1.height, obj2.y + obj2.height);
        w = Math.max(x_right - x_left, 0);
        h = Math.max(y_bottom - y_top, 0);
        if(w * h > 0) {
          return w > h ? [false, true] : [true, false]
        } else {
          return [false, false];
        }
      }
      
      const clamp = (x, min, max) => {
        return Math.min(Math.max(x, min), max);
      }

      const loop = () => {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        paddle.draw();
        ball.draw();
        block.draw();
        ctx_ui.clearRect(0, 0, canvas_ui.width, canvas_ui.height);
        ctx_ui.fillText('LEVEL', canvas_ui.width / 2, 30);
        ctx_ui.fillText(String(manager.level), canvas_ui.width / 2, 60);
        ctx_ui.fillText('SCORE', canvas_ui.width / 2, 120);
        ctx_ui.fillText(String(manager.score), canvas_ui.width / 2, 150);
        ctx_ui.fillText('LIFE', canvas_ui.width / 2, 210);
        ctx_ui.fillText(String(manager.life), canvas_ui.width / 2, 240);
        if (manager.state == 'play') {
          paddle.update();
          ball.update();

          ball_center_x = ball.x + ball.width / 2;
          ball_center_y = ball.y + ball.height / 2;

          if (ball_center_x < 0 || ball_center_x > canvas.width) ball.hit_x();
          if (ball_center_y < 0) ball.hit_y();
          if (ball_center_y > canvas.height) {
            manager.life += -1;
            manager.life == 0 ? manager.state = 'over' : manager.state = 'ready';
            ball.init();
          }
          
          [collision_x, collision_y] = collide(ball, paddle);
          if (collision_y || collision_x) {
            ball.hit_y();
            ball.is_bullet = paddle.is_hit_center(ball_center_x);
            if (paddle.is_hit_chip(ball_center_x)) {
              console.log("hit chip")
              paddle_center_x = paddle.x + 0.5 * paddle.width;
              if (ball_center_x > paddle_center_x) {
                ball.dx *= ball.dx > 0 ? 1 : -1;
              } else {
                ball.dx *= ball.dx > 0 ? -1 : 1;
              };
            }
          }

          if (ball.y < canvas.height * grid.canvas_ratio_y) {
            margin_x = 0.5 * (1 - grid.canvas_ratio_x) * canvas.width;
            x_index = Math.floor((ball_center_x - margin_x) / block.width);
            y_index = Math.floor(ball_center_y / block.height);
            index_keys = [
              x_index + y_index * grid.width,
              (x_index - 1) + y_index * grid.width,
              x_index + (y_index - 1) * grid.width,
              (x_index + 1) + y_index * grid.width,
              x_index + (y_index + 1) * grid.width
            ];

            for (const idx of index_keys) {
              if (idx in block.data) {
                [collision_x, collision_y] = collide(ball, block.data[idx]);
                if (!ball.is_bullet) collision_x ? ball.hit_x() : collision_y ? ball.hit_y() : ""
                if (collision_x || collision_y) {
                  brick.HP -= ball.damage;
                  if (brick.HP < 1 || ball.is_bullet) {
                    delete block.data[idx];
                    manager.score += 100
                  }
                }
              }
            }
          }
          
        } else if (manager.state == 'ready') {
          paddle.update();
          ball.x = paddle.x + paddle.width / 2 - ball.width / 2;
        }
        
        window.requestAnimationFrame(loop);
      }
      
      init();
      loop();

      document.addEventListener('keydown', e => {
        if(e.key == 'ArrowLeft') paddle.dx = -1 * paddle.speed;
        if(e.key == 'ArrowRight') paddle.dx = paddle.speed;
        if(e.key == 's' && manager.state == 'ready') manager.state = 'play';
        if(e.key == 'r') {
          manager.state = 'ready';
          init();
        }
        if(e.key == 'z') ball.speed = 2*cfg.ball.speed;
      });
      document.addEventListener('keyup', e => {
        if(e.key == 'z') ball.speed = cfg.ball.speed;
        paddle.dx = 0;
      });
      document.addEventListener('mousemove', e => {
        //console.log([e.x, e.y]);
        paddle.x = e.x > 0 ? e.x < canvas.width ? e.x : canvas.width : 0;
        paddle.x -= 0.5 * paddle.width
      });
      
    </script>
  </body>
</html>
